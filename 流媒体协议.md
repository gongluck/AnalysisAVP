# 流媒体协议

- [流媒体协议](#流媒体协议)
  - [RTMP](#rtmp)
    - [2.1. RTMP简介](#21-rtmp简介)
    - [2.2. RTMP播放基本流程](#22-rtmp播放基本流程)
    - [2.3. RTMP推流流程](#23-rtmp推流流程)
    - [2.4. RTMP拉流流程](#24-rtmp拉流流程)
    - [2.5. 握手](#25-握手)
      - [2.5.1. C0和S0](#251-c0和s0)
      - [2.5.2. C1和S1](#252-c1和s1)
      - [2.5.3. C2和S2](#253-c2和s2)
    - [2.6. RTMP Chunk Stream](#26-rtmp-chunk-stream)
      - [2.6.1. Message](#261-message)
      - [2.6.2. Chunk](#262-chunk)
        - [2.6.2.1. Chunk Format(块格式)](#2621-chunk-format块格式)
          - [2.6.2.1.1. Basic Header](#26211-basic-header)
          - [2.6.2.1.2. Message Header](#26212-message-header)
          - [2.6.2.1.3. Extended Timestamp](#26213-extended-timestamp)
          - [2.6.2.1.4. Chunk Data](#26214-chunk-data)
      - [2.6.3. 协议控制消息](#263-协议控制消息)
        - [2.6.3.1. Set Chunk Size(Message Type ID=1)](#2631-set-chunk-sizemessage-type-id1)
        - [2.6.3.2. Abort Message(Message Type ID=2)](#2632-abort-messagemessage-type-id2)
        - [2.6.3.3. Acknowledgement(Message Type ID=3)和Window Acknowledgement Size(Message Type ID=5)](#2633-acknowledgementmessage-type-id3和window-acknowledgement-sizemessage-type-id5)
        - [2.6.3.4. Set Peer Bandwidth(Message Type ID=6)](#2634-set-peer-bandwidthmessage-type-id6)
        - [2.6.3.5. Command Message(Message Type ID=17或20)](#2635-command-messagemessage-type-id17或20)
          - [2.6.3.5.1. NetConnection Commands(连接层的命令)](#26351-netconnection-commands连接层的命令)
          - [2.6.3.5.2. NetStream Commands(流连接上的命令)](#26352-netstream-commands流连接上的命令)
  - [HLS](#hls)
    - [3.1. HLS简介](#31-hls简介)
    - [3.2. M3U8](#32-m3u8)
      - [3.2.1. m3u8的常用参数](#321-m3u8的常用参数)
    - [3.3. TS](#33-ts)
      - [3.3.1. TS层](#331-ts层)
        - [3.3.1.1. TS Header](#3311-ts-header)
        - [3.3.1.2. adaptation field](#3312-adaptation-field)
        - [3.3.1.3. PAT](#3313-pat)
        - [3.3.1.4. PMT](#3314-pmt)
      - [3.3.2. PES层](#332-pes层)
      - [3.3.3. ES层](#333-es层)
  - [RTSP](#rtsp)
    - [4.1. RTSP简介](#41-rtsp简介)
    - [4.2. RTSP和相关协议](#42-rtsp和相关协议)
    - [4.3. RTP](#43-rtp)
      - [4.3.1. RTP报头结构](#431-rtp报头结构)
      - [4.3.2. RTP有效负荷](#432-rtp有效负荷)
        - [4.3.2.1. H264](#4321-h264)
          - [4.3.2.1.1. 单一NAL单元模式](#43211-单一nal单元模式)
          - [4.3.2.1.2. 组合打包模式](#43212-组合打包模式)
          - [4.3.2.1.3. 分包模式](#43213-分包模式)
        - [4.3.2.2. AAC](#4322-aac)
          - [4.3.2.2.1. AU Header Section](#43221-au-header-section)
    - [4.4. RTCP](#44-rtcp)
  - [WebSocket](#websocket)
  - [```WebRTC```](#webrtc)
    - [```WebRTC```框架](#webrtc框架)
    - [```WebRTC```连接过程](#webrtc连接过程)
    - [```ICE Candidate```](#ice-candidate)
    - [```SDP```](#sdp)
      - [```session metadata```](#session-metadata)
      - [```media section```](#media-section)
      - [修改```SDP```的例子](#修改sdp的例子)

## [RTMP](./analysis/rtmp)

### 2.1. RTMP简介

- **RTMP**(Real Time Messaging Protocol)是一个应用层协议,主要用于在**Flash player**和服务器之间传输视频、音频、控制命令等内容。该协议的突出优点是低延时。**RTMP**基于**TCP**,默认使用端口**1935**。
- **RTMP**协议是应用层协议,是要靠底层可靠的传输层协议(通常是**TCP**)来保证信息传输的可靠性的。在基于传输层协议的连接建立完成后,**RTMP**协议也要客户端和服务器通过"握⼿"来建立基于传输层连接之上的**RTMP Connection**连接,在Connection连接上会传输一些**控制信息**,如SetChunkSize,SetACKWindowSize。其中**CreateStream**命令会创建一个**Stream**连接,用于传输具体的音视频数据和控制这些信息传输的命令信息。**RTMP**协议传输时会对数据做自己的格式化,这种格式的消息我们称之为**RTMP Message**,而实际传输的时候为了更好地实现**多路复用、分包和信息的公平性**,发送端会把Message划分为**带有Message ID的Chunk**,每个Chunk可能是一个单独的Message,也可能是Message的一部分,在接收端会根据chunk中包含的data的长度、message id和message的长度把chunk还原成完整的Message,从而实现信息的收发。

### 2.2. RTMP播放基本流程

![RTMP播放基本流程](https://github.com/gongluck/images/blob/main/RTMP播放基本流程.png)

### 2.3. RTMP推流流程

![RTMP推流流程](https://github.com/gongluck/images/blob/main/RTMP推流流程.png)

### 2.4. RTMP拉流流程

![RTMP拉流流程](https://github.com/gongluck/images/blob/main/RTMP拉流流程.png)

### 2.5. 握手

![RTMP握手](https://github.com/gongluck/images/blob/main/RTMP握手.png)

- 要建立一个有效的**RTMP Connection**连接,首先要"握手"。
- 客户端要向服务器发送**C0、C1、C2**(按序)三个chunk,服务器向客户端发送**S0、S1、S2**(按序)三个chunk,然后才能进行有效的信息传输。RTMP协议本身并没有规定这6个**Message**的具体传输顺序,但RTMP协议的实现者需要保证这⼏点:

  - 客户端要等收到S1之后才能发送C2
  - 客户端要等收到S2之后才能发送其他信息(控制信息和真实音视频等数据)
  - 服务端要等到收到C0之后发送S1
  - 服务端必须等到收到C1之后才能发送S2
  - 服务端必须等到收到C2之后才能发送其他信息(控制信息和真实音视频等数据)

- 实际上,为了减少发送次数,一般是这样的:

  ![RTMP握手实际实现](https://github.com/gongluck/images/blob/main/RTMP握手实际实现.png)

  - Client -> Server:**C0+C1**
  - Server -> Client:**S0+S1+S2**
  - Client -> Server:**C2**

#### 2.5.1. C0和S0

![RTMP的C0和S0消息](https://github.com/gongluck/images/blob/main/RTMP的C0和S0消息.png)

- **C0**和**S0**包都是一个单一的**8位字节**。
- 在**C0**中,这一字段指示出客户端要求的RTMP版本号。
- 在**S0**中,这一字段指示出服务器端选择的RTMP版本号。
- **0、1、2**三个值是由早期݊其他产品使用的,是废弃值。
- **3**为规范的版本。
- **4-31**被保留为RTMP协议的未来实现版本使用。
- **32-255**不允许使用(来区分开**RTMP**和其他常用一个可打印字符开始的文本协议)。
- 无法识别客户端所要求版本号的服务器应该以版本**3**响应,(收到响应的)客户端可以选择降低到版本**3**,或者放弃握手。

#### 2.5.2. C1和S1

![RTMP的C1和S1消息](https://github.com/gongluck/images/blob/main/RTMP的C1和S1消息.png)

- **C1**和**S1**数据包的长度都是**1536**字节。
- **time**(4个字节),这个字段包含一个**timestamp**,用于本终端发送的所有后续块的时间起点。这个值可以是0,或者一些任意值。要同步多个块流,终端可以发送其他块流当前的**timestamp**的值。
- **zero**(4个字节),这个字段必需都是0。
- **random bytes**(1528个字节),这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手,这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护,也不需要动态值。

#### 2.5.3. C2和S2

![RTMP的C2和S2消息](https://github.com/gongluck/images/blob/main/RTMP的C2和S2消息.png)

  - **C2**和**S2**数据包的长度都是**1536**字节。
  - **time**(4个字节),这个字段必须包含终端在(**C2**响应的)**S1**或者(**S2**响应的)**C1**发的**timestamp**。
  - **time2**(4个字节),这个字段必须包含终端先前(**S1**或者**C1**)发出数据包**timestamp**。
  - **random echo**(1528个字节),这个字段必须包含终端发的(**C2**响应的)**S1**或者(**S2**响应的)**C1**的随机数。两端都可以一起使用**time**和**time2**字段再加当前**timestamp**快速估算带宽或者连接延迟,但这不太可能是有多大用处。

### 2.6. RTMP Chunk Stream

- **Chunk Stream**是对传输**RTMP Chunk**的流的逻辑上的抽象,客户端和服务器之间有关**RTMP**的信息都在这个流上通信。

#### 2.6.1. Message

![RTMP消息](https://github.com/gongluck/images/blob/main/RTMP消息.png)

- **TypeID**(类型ID):消息的类型ID,**1**个字节。
- **Payload Length**(长度):是指**Message Payload**(消息负载)音视频等信息的数据的长度,**3**个字节。
- **Timestamp**(时间戳):消息的时间戳(但不一定是当前时间),**4**个字节。
- **Message Stream ID**(消息的流ID):每个消息的唯一标识,划分成**Chunk**和还原**Chunk**为**Message**的时候都是根据这个**ID**来辨识是否是同一个消息的**Chunk**的,**4(3?)**个字节,并且以**小端**格式存储。

#### 2.6.2. Chunk

- **RTMP**在收发数据的时候并不是以**Message**为单位的,而是把**Message**拆分成**Chunk**发送,而且必须在一个**Chunk**发送完成之后才能开始发送下一个**Chunk**。每个**Chunk**中带有**MessageID**代表属于哪个**Message**,接收端也会按照这个**id**来将**chunk**组装成**Message**。
- **Chunk**的默认大小是**128**字节,在传输过程中,通过一个叫做**Set Chunk Size**的控制信息可以设置**Chunk**数据量的**最大值**,在发送端和接收端会各自维护一个**Chunk Size**,可以分别设置这个值来改变自己这一方发送的**Chunk**的**最大大小**。

##### 2.6.2.1. Chunk Format(块格式)

![RTMP块格式](https://github.com/gongluck/images/blob/main/RTMP块格式.png)
![RTMP的块头1](https://github.com/gongluck/images/blob/main/RTMP的块头1.png)
![RTMP的块头2](https://github.com/gongluck/images/blob/main/RTMP的块头2.png)

###### 2.6.2.1.1. Basic Header

- 包含了**chunk stream ID**(流通道ID)和**chunk type**(chunk的类型),**chunk stream id**一般被简写为**CSID**,用来唯一标识一个特定的流通道,**chunk type**决定了后面**Message Header**的格式。
- **Basic Header**的长度可能是**1、2或3个字节**,其中**chunk type**的长度是固定的**2bit**,**Basic Header**是变长的,其长度取决于**CSID**的大小,在足够存储这两个字段的前提下最好用尽量少的字节从而减少由于引入Header增加的数据量。
- **RTMP**协议最多支持**65597**个用户自定义**chunk stream ID**,范围为 **[3,65599]**,**ID 0、1、2**被协议规范直接使用,其中**ID值为0、1分表表示了Basic Header占用2个字节和3个字节**。
- **CSID值0**:代表**Basic Header**占用**2**个字节,**CSID**在 **[64,319]** 之间。
- **CSID值1**:代表**Basic Header**占用**3**个字节,**CSID**在 **[64,65599]** 之间。
- **CSID值2**:代表该**chunk**是**控制信息和一些命令信息**。
- 当**Basic Header**为**1**个字节时,**CSID**占**6**位,6位最多可以表示64个数,因此这种情况下**CSID**在 **[0,63]** 之间,其中用户可自定义的范围为 **[3,63]**。

![RTMP块基础头1](https://github.com/gongluck/images/blob/main/RTMP块基础头1.png)

- 当**Basic Header**为**2**个字节时,**CSID**只占**8**位,第一个字节除**chunk type**占用的bit都置为**0**,第二个字节用来表示**CSID - 64**,8位可以表示 **[0, 255]** 共256个数,ID的计算方法为(第二个字节+64),范围为 **[64,319]**。

![RTMP块基础头2](https://github.com/gongluck/images/blob/main/RTMP块基础头2.png)

- 当**Basic Header**为**3**个字节时,**ID的计算方法为(第三字节*256+第二字节+64)**(Basic Header是采用小端存储的方式),范围为 **[64,65599]**。

![RTMP块基础头3](https://github.com/gongluck/images/blob/main/RTMP块基础头3.png)

###### 2.6.2.1.2. Message Header

- **Message Header**的格式和长度取决于**Basic Header**的**chunk type**,共有**4**种不同的格式,由上面所提到的**Basic Header**中的 **fmt(CSID)** 字段控制。

####### 2.6.2.1.2.1. fmt=00

![RTMP的块消息头1](https://github.com/gongluck/images/blob/main/RTMP的块消息头1.png)

- **Message Header**占用**11**个字节,其他三种能表示的数据它都能表示,但在**chunk stream**的开始的第一个**chunk**和头信息中的时间戳后退(即值与上一个**chunk**相比减小,通常在回退播放的时候会出现这种情况)的时候必须采用这种格式。
- **timestamp**(时间戳):占用**3**个字节,因此它最多能表示到**16777215 = 0xFFFFFF = (2^24)-1**, 当它的值超过这个最大值时,这三个字节都置为**1**,这样实际的**timestamp**会转存到**Extended Timestamp**字段中,接收端在判断**timestamp**字段**24**个位都为**1**时就会去**Extended timestamp**中解析实际的时间戳。
- **message length**(消息数据的长度):占用**3**个字节,表示实际发送的消息的数据如音频帧、视频帧等数据的长度,单位是字节。注意这里是**Message**的长度,也就是**chunk**属于的**Message**的总数据长度,而不是**chunk**本身**Data**的数据的长度。
- **message type id**(消息的类型ID):占用**1**个字节,表示实际发送的数据的类型,如8代表音频数据、9代表视频数据。
- **msg stream id**(消息的流ID):占用**4**个字节,表示该**chunk**所在的流的**ID**,和**Basic Header**的**CSID**一样,它采用小端存储的方式。

####### 2.6.2.1.2.2. fmt=01

![RTMP的块消息头2](https://github.com/gongluck/images/blob/main/RTMP的块消息头2.png)

- **Message Header**占用**7**个字节,省去了表示**msg stream id**的**4**个字节,表示此**chunk**和上一次发的**chunk**所在的流相同,如果在发送端只和对端有一个流连接的时候可以尽量去采取这种格式。
- **timestamp delta**占用**3**个字节,注意这里和**fmt=00**时不同,存储的是和上一个**chunk**的时间差。类似上面提到的**timestamp**,当它的值超过**3**个字节所能表示的最大值时,三个字节都置为**1**,实际的时间戳差值就会转存到**Extended Timestamp**字段中,接收端在判断**timestamp delta**字段**24**个位都为**1**时就会去**Extended timestamp**中解析时机的与上次时间戳的差值。

####### 2.6.2.1.2.3. fmt=10

![RTMP的块消息头3](https://github.com/gongluck/images/blob/main/RTMP的块消息头3.png)

- **Message Header**占用**3**个字节,相对于**fmt=01**格式又省去了表示消息长度的**3**个字节和表示消息类型的**1**个字节,表示此**chunk**和上一次发送的**chunk**所在的流、消息的长度和消息的类型都相同。余下的这三个字节表示**timestamp delta**,使用同**fmt=01**。

####### 2.6.2.1.2.4. fmt=11

- **0**字节！！！表示这个**chunk**的**Message Header**和上一个是完全相同的,自然就不用再传输一遍了。
- 当它跟在**fmt=00**的**chunk**后面时,表示和前一个**chunk**的时间戳都是相同的。就是一个**Message**拆分成了多个**chunk**,这个**chunk**和上一个**chunk**同属于一个**Message**。
- 当它跟在**fmt=01**或者**fmt=10**的**chunk**后面时,表示和前一个**chunk**的时间戳的差是相同的。

###### 2.6.2.1.3. Extended Timestamp

- 只有时间戳大于**3**个字节能表示的最大数值**0xFFFFFF=16777215**时,才会用这个字段来表示真正的时间戳,否则这个字段为**0**。
- 扩展时间戳占**4**个字节,能表示的最大数值就是**0xFFFFFFFF=4294967295**。当扩展时间戳启用时,**timestamp**字段或者**timestamp delta**要全置为**0xFFFFFF**,表示应该去扩展时间戳字段来提取真正的时间戳或者时间戳差。
- 扩展时间戳存储的是完整值,而不是减去时间戳或者时间戳差的值。

###### 2.6.2.1.4. Chunk Data

- 用户层真正要发送的与协议无关的数据,长度在 **(0,chunkSize]** 之间。

#### 2.6.3. 协议控制消息

- **RTMP**的**chunk**流会用一些特殊的值来代表协议的控制消息,它们的**Message Stream ID**必须为**0**(代表控制流信息),**CSID**必须为**2**,**Message Type ID**可以为**1、2、3、5、6**。控制消息的接收端会忽略掉**chunk**中的时间戳,收到后立即生效。

##### 2.6.3.1. Set Chunk Size(Message Type ID=1)

![RTMP的SetChunkSize消息数据](https://github.com/gongluck/images/blob/main/RTMP的SetChunkSize消息数据.png)

- 设置**chunk**中**Data**字段所能承载的最大字节数,默认为**128B**,通信过程中可以通过发送该消息来设置**chunk size**的大小(不得小于128B),而且通信双方会各自维护一个**chunk size**,两端的**chunkSize**是独立的。其中第一位必须为**0**,**chunk size**占**31**个位,最大可代表**2147483647 = 0x7FFFFFFF = (2^31)-1**。

##### 2.6.3.2. Abort Message(Message Type ID=2)

![RTMP的AbortMessage消息数据](https://github.com/gongluck/images/blob/main/RTMP的AbortMessage消息数据.png)

- 当一个**Message**被切分为多个**chunk**,接收端只接收到了部分**chunk**时,发送该控制消息表示发送端不再传输同**Message**的**chunk**,接收端接收到这个消息后要丢弃这些不完整的**chunk**。**Data**数据中只需要一个**CSID**,表示丢弃该**CSID**的所有已接收到的**chunk**。

##### 2.6.3.3. Acknowledgement(Message Type ID=3)和Window Acknowledgement Size(Message Type ID=5)

![RTMP的Acknowledgement消息数据](https://github.com/gongluck/images/blob/main/RTMP的Acknowledgement消息数据.png)
![RTMP的WindowAcknowledgementSize消息数据](https://github.com/gongluck/images/blob/main/RTMP的WindowAcknowledgementSize消息数据.png)

- **Window Acknowledgement Size**用于设置窗口确认大小,**Acknowledgement**是窗口确认消息。
- 会话开始时,双方都要向对端发送**Window Acknowledgement Size**,用于指明期望获得确认的大小。当一端收到内容大小超过**Window Acknowledgement Size**,就要向对方发送**Acknowledgement**。

  - 会话开始计算收到byte个数的时间点是收到**Window Acknowledgement Size**消息开始。
  - byte size不包括tcp包头,应该是chunk的大小,即从tcp的recv函数中获得的内容大小。
  - 双方都要向对方发送**Window Acknowledgement Size**和**Acknowledgement**。
  - 发送端发送完**Window Acknowledgement Size**消息后,没有收到**Acknowledgement**是不再发送进一步的消息的(这样会容易引起错误,导致再也发送不出消息了)。
  - 对于拉流端,一般在收到**av_createStream**后,接着**play**,然后发送**Acknowledgement**以让服务器继续发送数据。

##### 2.6.3.4. Set Peer Bandwidth(Message Type ID=6)

![RTMP的SetPeerBandwidth消息数据](https://github.com/gongluck/images/blob/main/RTMP的SetPeerBandwidth消息数据.png)

- 限制对端的输出带宽。接收端接收到该消息后会通过设置消息中的**Window ACK Size**来限制已发送但未接收到反馈的消息的大小来限制发送端的发送带宽。如果消息中的**Window ACK Size**与上一次发送给发送端的**size**不同的话要回馈一个**Window Acknowledgement Size**的控制消息。
- **Hard(Limit Type=0)**:接收端应该将**Window Ack Size**设置为消息中的值。
- **Soft(Limit Type=1)**:接收端可以将**Window Ack Size**设为消息中的值,也可以保存原来的值(前提是原来的**Size**小于该控制消息中的**Window Ack Size**)。
- **Dynamic(Limit Type=2)**:如果上次的**Set Peer Bandwidth**消息中的**Limit Type**为**0**,本次也按**Hard**处理,否则忽略本消息,不去设置**Window Ack Size**。

##### 2.6.3.5. Command Message(Message Type ID=17或20)

- 发送端发送时会带有命令的名字,**TransactionID**表示此次命令的标识,**Command Object**表示相关参数。接收端收到命令后,会返回以下三种消息中的一种:
  
  - **_result**消息表示接收该命令,对端可以继续往下执行流程。
  - **_error**消息代表拒绝该命令要执行的操作。
  - **method name**消息代表要在之前命令的发送端执行的函数名称。
  - 这三种回应的消息都要带有收到的命令消息中的**TransactionID**来表示本次的回应作用于哪个命令。可以认为发送命令消息的对象有两种,一种是**NetConnection**,表示双端的上层连接,一种是**NetStream**,表示流信息的传输通道,控制流信息的状态,如Play播放流、Pause暂停。

###### 2.6.3.5.1. NetConnection Commands(连接层的命令)

- 用来管理双端之间的连接状态,同时也提供了异步远程方法调用(RPC)在对端执行某方法。

####### 2.6.3.5.1.1. connect

- 用于客户端向服务器发送连接请求。
      
  |                  字段                   |  类型  | 说明                     |
  | :-------------------------------------: | :----: | :----------------------- |
  |         Command Name(命令名字)          | String | "connect"                |
  |         Transaction ID(事务ID)          | Number | 1                        |
  |   Command Object(命令包含的参数对象)    | Object | 键值对集合表示的命令参数 |
  | Optional User Arguments(额外的用户参数) | Object | 用户自定义的额外信息     |
  
- 连接命令对象中使用的名称-值对:
  
  |      属性      |  类型   | 描述                                                                           | 范例                                   |
  | :------------: | :-----: | :----------------------------------------------------------------------------- | :------------------------------------- |
  |      app       | String  | 客户端连接到的服务器端应用的名字                                               | testapp                                |
  |    flashver    | String  | Flash Player版本号<br>和ApplicationScript getversion()方法返回的是同一个字符串 | FMSc/1.0                               |
  |     swfUrl     | String  | 进行当前连接的SWF文件源地址                                                    | file://C:/FlvPlayer.swf                |
  |     tcUrl      | String  | 服务器URL<br>格式:protocol://servername:port/appName/appInstance               | rtmp://localhost:1935/testapp/instance |
  |      fpad      | Boolean | 使用了代理                                                                     | true                                   |
  |  audioCodecs   | Number  | 表明客户端所支持的音频编码                                                     | SUPPORT_SND_MP3                        |
  |  videoCodecs   | Number  | 表明支持的视频编码                                                             | SUPPORT_VID_SORENSON                   |
  | videoFunction  | Number  | 表明所支持的特殊视频方法                                                       | SUPPORT_VID_CLIENT_SEEK                |
  |    pageUrl     | String  | SWF文件所加载的网页URL                                                         | http://somehost/sample.html            |
  | objectEncoding | Number  | AMF编码方法                                                                    | AMF3                                   |
  
####### 2.6.3.5.1.2. call

- 用于在对端执行某函数,即常说的**RPC**(远程进程调用)。

  |                  字段                   |  类型  | 说明                                   |
  | :-------------------------------------: | :----: | :------------------------------------- |
  |         Procedure Name(进程名)          | String | 要调用的进程名称                       |
  |         Transaction ID(事务ID)          | Number | 如果想要对端响应的话置为⾮0值,否则置为0 |
  |   Command Object(命令包含的参数对象)    | Object | 键值对集合表示的命令参数               |
  | Optional User Arguments(额外的用户参数) | Object | 用户自定义的额外信息                   |
  
- 如果消息中的**TransactionID**不为**0**的话,对端需要对该命令做出响应,响应的消息结构:

  |                  字段                   |  类型  | 说明                                  |
  | :-------------------------------------: | :----: | :------------------------------------ |
  |         Transaction ID(事务ID)          | Number | 上面接收到的命令消息中的TransactionID |
  |   Command Object(命令包含的参数对象)    | Object | 键值对集合表示的命令参数              |
  | Optional User Arguments(额外的用户参数) | Object | 用户自定义的额外信息                  |

####### 2.6.3.5.1.3. createStream

- 创建传递具体信息的通道,从而可以在这个流中传递具体信息,传输信息单元为**chunk**。当发送完**createStream**消息之后,解析服务器返回的消息会得到一个**stream ID**,这个**ID**也就是以后和服务器通信的**message stream ID**,一般返回的是**1**,不固定。

  |                  字段                   |  类型  | 说明                     |
  | :-------------------------------------: | :----: | :----------------------- |
  |         Command Name(命令名字)          | String | "createStream"           |
  |         Transaction ID(事务ID)          | Number | 一般返回的是**1**,不固定 |
  |   Command Object(命令包含的参数对象)    | Object | 键值对集合表示的命令参数 |
  | Optional User Arguments(额外的用户参数) | Object | 用户自定义的额外信息     |

###### 2.6.3.5.2. NetStream Commands(流连接上的命令)

- **NetStream**建立在**NetConnection**之上,通过**NetConnection**的**createStream**命令创建,用于传输具体的音频、视频等信息。在传输层协议之上只能连接一个**NetConnection**(TCP连接),但一个**NetConnection**可以建立多个**NetStream**来建立不同的流通道传输数据。

####### 2.6.3.5.2.1. onStatus

- 服务端收到**NetStream**命令后会通过**onStatus**的命令来响应客户端,表示当前**NetStream**的状态。

  |                字段                |  类型  | 说明                                                                                                                                                                                                                                                                                                                                |
  | :--------------------------------: | :----: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |       Command Name(命令名字)       | String | "onStatus"                                                                                                                                                                                                                                                                                                                          |
  |       Transaction ID(事务ID)       | Number | 0                                                                                                                                                                                                                                                                                                                                   |
  | Command Object(命令包含的参数对象) |  NULL  |                                                                                                                                                                                                                                                                                                                                     |
  |            Info Object             | Object | AMF类型的Object,至少包含以下三个属性:<br>1、"level",String类型,可以为"warning"、"status"、"error"中的一种<br>2、"code",String类型,代表具体状态的关键字,比如"NetStream.Play.Start"表示开始播流<br>3、"description",String类型,代表对当前状态的描述,提供对当前状态可读性更好的解释,除了这三种必要信息,用户还可以自⼰增加自定义的键值对 |

####### 2.6.3.5.2.2. play

- 由客户端向服务器发起请求从服务器端接收数据(如果传输的信息是视频的话就是请求开始播流),可以多次调用,这样本地就会形成一组数据流的接收者。其中有一个**reset**字段,表示是覆盖之前的播流(设为true)还是重新开始一路播放(设为false)。

  |                字段                |  类型   | 说明                                                                                                                                                                                                                                                                                                                                                                                           |
  | :--------------------------------: | :-----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |       Command Name(命令名字)       | String  | "play"                                                                                                                                                                                                                                                                                                                                                                                         |
  |       Transaction ID(事务ID)       | Number  | 0                                                                                                                                                                                                                                                                                                                                                                                              |
  | Command Object(命令包含的参数对象) |  NULL   |                                                                                                                                                                                                                                                                                                                                                                                                |
  |         StreamName(流名称)         | String  | 要播放的流的名称                                                                                                                                                                                                                                                                                                                                                                               |
  |              开始位置              | Number  | 可选参数,表示从何时开始播流,以秒为单 位。默认为－2,代表选取对应该流名称的直播流,即当前正在推送的流开始播放,如果对应该名称的直播流不存在,就选取该名称的流的录播版本,如果这也没有,当前播流端要等待直到对端开始该名称的流的直播。如果传值－1,那么只会选取直播流进行播放,即使有录播流也不会播放；如果传值或者正数,就代表从该流的该时间点开始 播放,如果流不存在的话就会自动播放播放列表中的下一个流 |
  |                周期                | Number  | 可选参数,表示回退的最小间隔单位,以秒为单位计数。默认值为－1,代表直到直播流不再可用或者录播流停止后才能回退播放；如果传值为0,代表从当前帧开始播放                                                                                                                                                                                                                                               |
  |                重置                | Boolean | 可选参数,true代表清除之前的流,重新开始一路播放,false代表保留原来的流,向本地的播放列表中再添加一条播放流                                                                                                                                                                                                                                                                                        |

####### 2.6.3.5.2.3. play2

- 和上面的**play**命令不同,**play2**命令可以将当前正在播放的流切换到同样数据但不同比特率的流上,服务器端会维护多种比特率的文件来供客户端使用play2命令来切换。

  |                字段                |  类型  | 说明                                                                                          |
  | :--------------------------------: | :----: | :-------------------------------------------------------------------------------------------- |
  |       Command Name(命令名字)       | String | "play"                                                                                        |
  |       Transaction ID(事务ID)       | Number | 0                                                                                             |
  | Command Object(命令包含的参数对象) |  NULL  |                                                                                               |
  |             parameters             | Object | AMF编码的Flash对象,包括了一些用于描述flash.net.NetstreamPlayOptions ActionScript obejct的参数 |

####### 2.6.3.5.2.4. deleteStream

- 用于客户端告知服务器端本地的某个流对象已被删除,不需要再传输此路流。

  |                字段                |  类型  | 说明                                  |
  | :--------------------------------: | :----: | :------------------------------------ |
  |       Command Name(命令名字)       | String | "deleteStream"                        |
  |       Transaction ID(事务ID)       | Number | 0                                     |
  | Command Object(命令包含的参数对象) |  NULL  |                                       |
  |          Stream ID(流ID)           | Number | 本地已删除,不再需要服务器传输的流的ID |

####### 2.6.3.5.2.5. receiveAudio

- 通知服务器端该客户端是否要发送音频。

  |                字段                |  类型   | 说明                                                                                                                                                                                        |
  | :--------------------------------: | :-----: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
  |       Command Name(命令名字)       | String  | "receiveAudio"                                                                                                                                                                              |
  |       Transaction ID(事务ID)       | Number  | 0                                                                                                                                                                                           |
  | Command Object(命令包含的参数对象) |  NULL   |                                                                                                                                                                                             |
  |             Bool Flag              | Boolean | true表示发送音频,如果该值为false,服务器端不做响应,如果为true的话,服务器端就会准备接收音频数据,会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态 |

####### 2.6.3.5.2.6. receiveVideo

- 通知服务器端该客户端是否要发送视频。

  |                字段                |  类型   | 说明                                                                                                                                                                                        |
  | :--------------------------------: | :-----: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
  |       Command Name(命令名字)       | String  | "receiveVideo"                                                                                                                                                                              |
  |       Transaction ID(事务ID)       | Number  | 0                                                                                                                                                                                           |
  | Command Object(命令包含的参数对象) |  NULL   |                                                                                                                                                                                             |
  |             Bool Flag              | Boolean | true表示发送视频,如果该值为false,服务器端不做响应,如果为true的话,服务器端就会准备接收视频数据,会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态 |

####### 2.6.3.5.2.7. publish

- 由客户端向服务器发起请求推流到服务器。

  |                字段                |  类型  | 说明                                                                                                                                                                                                                                                                                                                                               |
  | :--------------------------------: | :----: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |       Command Name(命令名字)       | String | "publish"                                                                                                                                                                                                                                                                                                                                          |
  |       Transaction ID(事务ID)       | Number | 0                                                                                                                                                                                                                                                                                                                                                  |
  | Command Object(命令包含的参数对象) |  NULL  |                                                                                                                                                                                                                                                                                                                                                    |
  |    Publishing Name(推流的名称)     | String | 流名称                                                                                                                                                                                                                                                                                                                                             |
  | Command Object(命令包含的参数对象) | String | "live"、"record"、"append"中的一种。<br>live表示该推流文件不会在服务器端存储<br>record表示该推流的文件会在服务器应用程序下的子目录下保存以便后续播放,如果文件已经存在的话删除原来所有的内容重新写入<br>append也会将推流数据保存在服务器端,如果文件不存在的话就会建立一个新文件写入,如果对应该流的文件已经存在的话保存原来的数据,在文件末尾接着写入 |

####### 2.6.3.5.2.8. seek

- 定位到视频或音频的某个位置,以毫秒为单位。

  |                字段                |  类型  | 说明                   |
  | :--------------------------------: | :----: | :--------------------- |
  |       Command Name(命令名字)       | String | "seek"                 |
  |       Transaction ID(事务ID)       | Number | 0                      |
  | Command Object(命令包含的参数对象) |  NULL  |                        |
  |            milliSeconds            | Number | 定位到该文件的xx毫秒处 |

####### 2.6.3.5.2.9. pause

- 客户端告知服务端停止或恢复播放。
- 如果**Pause**为**true**即表示客户端请求暂停的话,服务端暂停对应的流会返回**NetStream.Pause.Notify**的**onStatus**命令来告知客户端当前流处于暂停的状态,当**Pause**为**false**时,服务端会返回**NetStream.Unpause.Notify**的命令来告知客户端当前流恢复。如果服务端对该命令响应失败,返回 **_error** 信息。

  |                字段                |  类型   | 说明                            |
  | :--------------------------------: | :-----: | :------------------------------ |
  |       Command Name(命令名字)       | String  | "pause"                         |
  |       Transaction ID(事务ID)       | Number  | 0                               |
  | Command Object(命令包含的参数对象) |  NULL   |                                 |
  |         Pause/Unpause Flag         | Boolean | true表示暂停,false表示恢复      |
  |            milliSeconds            | Number  | 暂停或者恢复的时间,以毫秒为单位 |

## [HLS](./analysis/hls)

### 3.1. HLS简介

![HLS框架](https://github.com/gongluck/images/blob/main/HLS框架.png)

- 作为**Apple**提出的一种基于**HTTP**的协议,**HLS(HTTP Live Streaming)**用于解决实时音视频流的传输。尤其是在移动端,由于**iOS/H5**不支持**flash**,使得**HLS**成了移动端实时视频流传输的首选。**HLS**经常用在直播领域,一些国内的直播云通常用**HLS**拉流。
- **HLS**值得诟病之处就是其延迟严重,延迟通常在**10-30s**之间。
- **流分割器(Stream Segmenter)**负责将编码器输出的**MPEG-2 TS**流分割为一系列**连续的、长度均等的**小**TS**文件,并依次发送至内容分发组件中的**Web**服务器进行存储。
- 为了跟踪播放过程中媒体文件的可用性和当前位置,流分割器还需创建一个含有指向这些小**TS**文件指针的索引文件,同样放置于**Web**服务器之中。这个索引文件可以看作是一个连续媒体流中的播放列表滑动窗口,每当流分割器生成一个新的**TS**文件时,这个索引文件的内容也被更新,新的文件**URI**加入到滑动窗口的末尾,老的文件**URI**则被移去,这样索引文件中将始终包含最新的固定数量的x个分段。流分割器还可以对其生成的每个小**TS**文件进行加密,并生成相应的密钥文件。
- 之所以采用**MPEG-2 TS**格式来对编码后的媒体流进行统一封装,是因为它能够将音视频媒体流严格按时序进行交织复用,任意截取和分段后,每一个分段都可能不依赖于之前的分段而独立进行解码和播放。为此,**TS**文件中必须仅包含一个**MPEG-2**节目,在每个文件的开头应包含一个**节目关联表(PAT)**和一个**节目映射表(PMT)**,包含视频的文件中还必须含有至少一个**关键帧和其他足够信息(如序列头)**用以完成解码器的初始化。索引文件采用扩展的**M3U**播放列表格式,后缀名为 **.m3u8** 。M3U播放列表是一个由若干文本行组成的文本文件,其中每一行要么是一个URI,一个空行,或者是一个以注释符"#"起始的行。每个URI行指向一个分段的媒体文件,或者一个衍生的索引(播放列表)文件。除了以"#EXT"起始的行是标签行外,其他以"#"起始的行是注释,应予忽略。
- **HTTP Live Streaming**并不是一个真正实时的流媒体系统,这是因为对应于媒体分段的大小和持续时间有一定潜在的时间延迟。在客户端中,至少在一个分段媒体文件被完全下载之后才能够开始播放,而通常要求下载完成两个分段媒体文件之后才开始播放以保证不同分段音视频之间的无缝连接。此外,在客户端开始下载之前,必须等待服务器端的编码器和流分割器至少生成一个TS文件,这也会带来潜在的时延。在推荐配置下,HTTP Live Streaming系统的典型时延约在**30s**左右。
- 在基于**HTTP Live Streaming**的流媒体系统中,服务器可以为同一节目源准备多份以不同码率和质量编码的替换流,并为每个替换流都生成一个衍生的索引文件。在主索引文件中通过包含一系列指向其他衍生索引文件的URI指针来找到相应的替换流。
- 相对于常⻅的流媒体直播协议,例如RTMP协议、RTSP协议、MMS协议等,HLS直播最大的不同在于,直播客户端获取到的,并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件(MPEG-TS格式),而客户端则不断的下载并播放这些小文件,因为服务器端总是会将最新的直播数据生成新的小文件,这样客户端只要不停的按顺序播放从服务器获取到的文件,就实现了直播。由此可⻅,基本上可以认为,HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输,所以完全不用考虑防⽕墙或者代理的问题,而且分段文件的时长很短,客户端可以很快的选择和切换码率,以适应不同带宽条件下的播放。不过HLS的这种技术特点,决定了它的延迟一般总是会高于普通的流媒体直播协议。
- HLS协议优势

  - HLS相对于RTMP来讲使用了标准的HTTP协议来传输数据,可以避免在一些特殊的网络环境下被屏蔽。
  - HLS相比RTMP在服务器端做负载均衡要简单得多。因为HLS是基于无状态协议HTTP实现的,客户端只需要按照顺序使用下载存储在服务器的普通ts文件进行播放就可以。而RTMP是一种有状态协议,很难对视频服务器进行平滑扩展,因为需要为每一个播放视频流的客户端维护状态。
  - HLS协议本身实现了码率自适应,在不同带宽情况下,设备可以自动切换到最适合自己码率的视频播放。

- HLS协议劣势

  - HLS协议在直播的视频延迟时间很难做到10s以下延时,而RTMP协议的延时可以降到1s左右。

### 3.2. M3U8

- **HLS**的**m3u8**,是一个**ts**的列表,也就是告诉浏览器可以播放这些**ts**文件。

#### 3.2.1. m3u8的常用参数

|        配置项         |                                                                        作用                                                                         |
| :-------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------: |
|        #EXTM3U        |                                                      每个M3U文件第一行必须是这个tag,起标示作用                                                      |
|    #EXT-X-VERSION     |                                                    该属性可以没有,目前主要是version 3,最新的是7                                                     |
| #EXT-X-MEDIA-SEQUENCE |                      每一个media URI在PlayList中只有唯一的序号,相邻之间序号+1,一个media URI并不是必须要包含的,如果没有,默认为0                      |
| #EXT-X-TARGETDURATION |     所有切片的最大时长。有些Apple设备这个参数不正确会无法播放。SRS会自动计算出ts文件的最大时长,然后更新m3u8时会自动更新这个值。用户不必自己配置     |
|        #EXTINF        |                                       ts切片的实际时长,SRS提供配置项hls_fragment,但实际上的ts时长还受gop影响                                        |
|     ts文件的数目      | SRS可配置hls_window(单位是秒,不是数量),指定m3u8中保存多少个切片。譬如,每个ts切片为10秒,窗口为60秒,那么m3u8中最多保存6个ts切片,SRS会自动清理旧的切片 |
|    livestream-0.ts    |                    SRS会自动维护ts切片的文件名,在编码器重推之后,这个编号会继续增长,保证流的连续性。直到SRS重启,这个编号才重置为0                    |

### 3.3. TS

![TS文件分层](https://github.com/gongluck/images/blob/main/TS文件分层.png)

- **ts**文件为传输流文件,视频编码主要格式为**H264/MPEG4**,音频为**AAC/MP3**。
- ts传输流,是由固定长度的包组成,含有独立时间基准的一个或多个节目,适用于误码较多的环境,并且从流的任意一段开始都可以独立解码。在MPEG-2系统中,由视频、音频的ES流和辅助数据复接生成的用于实际传输的标准信息流称为MPEG-2传送流。TS流是原始的PES流中按照一定的频率插入PSI/SI和一些标识符(辅助数据)信息,然后按固定长度打包形成的传输流。PSI/SI信息在TS流中并不是只发送一次,而是按照一定的频率插入码流重复发送的。
- TS包的长度:**188B或204B**,204B长度是在188B后面增加了16B的CRC校验数据。

#### 3.3.1. TS层

![TS流](https://github.com/gongluck/images/blob/main/TS流.png)

- **ts**层:Transport Stream,是在pes层的基础上加入数据流的识别和传输必须的信息。
- ts包大小固定为**188**字节,ts层分为三个部分:**ts header、adaptation field、payload**。
- ts层的内容是通过**PID**值来标识的,主要内容包括:**PAT表、PMT表、音频流、视频流**。解析ts流要先找到PAT表,只要找到PAT就可以找到PMT,然后就可以找到音视频流了。PAT表和PMT表需要定期插入ts流,因为用户随时可能加入ts流,这个间隔比较小,通常每隔⼏个视频帧就要加入PAT和PMT。PAT和PMT表是必须的,还可以加入其它表如SDT(业务描述表)等,不过hls流只要有PAT和PMT就可以播放了。
  
  - PAT表:主要的作用就是指明了PMT表的PID值。
  - PMT表:主要的作用就是指明了音视频流的PID值。

##### 3.3.1.1. TS Header

|             名称             | 长度  |                                                          说明                                                          |
| :--------------------------: | :---: | :--------------------------------------------------------------------------------------------------------------------: |
|          sync_byte           |  8b   |                                                  同步字节,固定为0x47                                                   |
|  transport_error_indicator   |  1b   |                 传输错误指示符,表明在ts头的adapt域后有一个无用字节,通常都为0,这个字节算在adapt域长度内                 |
| payload_unit_start_indicator |  1b   |                                    负载单元起始标示符,一个完整的数据包开始时标记为1                                    |
|      transport_priority      |  1b   |                                       传输优先级,0为低优先级,1为高优先级,通常取0                                       |
|             pid              |  13b  |                                                         pid值                                                          |
| transport_scrambling_control |  2b   |                                               传输加扰控制,00表示未加密                                                |
|   adaptation_field_control   |  2b   | 是否包含自适应区,"00"保留;"01"为无自适应域,仅含有效负载;"10"为仅含自适应域,无有效负载;"11"为同时带有自适应域和有效负载 |
|      continuity_counter      |  4b   |                                    递增计数器,从0-f,起始值不一定取0,但必须是连续的                                     |

- ts header固定**4**个字节,adaptation field可能存在也可能不存在,主要作用是给不足188字节的数据做填充,payload是pes数据。

##### 3.3.1.2. adaptation field

|          名称           | 长度  |                                              说明                                               |
| :---------------------: | :---: | :---------------------------------------------------------------------------------------------: |
| adaptation_field_length |  1B   |                                    自适应域长度,后面的字节数                                    |
|          flag           |  1B   |                              取0x50表示包含PCR或0x40表示不包含PCR                               |
|           PCR           |  5B   | Program Clock Reference,节目时钟参考,用于恢复出与编码端一致的系统时序时钟STC(System Time Clock) |
|     stuffing_bytes      |  xB   |                                        填充字节,取值0xff                                        |

##### 3.3.1.3. PAT

|           名称           | 长度  |                           说明                           |
| :----------------------: | :---: | :------------------------------------------------------: |
|         table_id         |  8b   |                     PAT表固定为0x00                      |
| section_syntax_indicator |  1b   |                         固定为14                         |
|           zero           |  1b   |                         固定为0                          |
|         reserved         |  2b   |                         固定为11                         |
|      section_length      |  12b  |                      后面数据的长度                      |
|   transport_stream_id    |  16b  |                  传输流ID,固定为0x0001                   |
|         reserved         |  2b   |                         固定为11                         |
|      version_number      |  5b   |       版本号,固定为00000,如果PAT有变化则版本号加1        |
|  current_next_indicator  |  1b   |  固定为1,表示这个PAT表可以用,如果为0则要等待下一个PAT表  |
|      section_number      |  8b   |                        固定为0x00                        |
|   last_section_number    |  8b   |                        固定为0x00                        |
|         开始循环         |       |                                                          |
|      program_number      |  16b  | 节目号为0x0000时表示这是NIT,节目号为0x0001时,表示这是PMT |
|         reserved         |  3b   |                        固定为111                         |
|           PID            |  13b  |                  节目号对应内容的PID值                   |
|         结束循环         |       |                                                          |
|          CRC32           |  32b  |                  前面数据的CRC32校验码                   |

##### 3.3.1.4. PMT

|           名称           |   长度   |                                           说明                                            |
| :----------------------: | :------: | :---------------------------------------------------------------------------------------: |
|         table_id         |    8b    |                                    PMT表取值随意,0x02                                     |
| section_syntax_indicator |    1b    |                                          固定为1                                          |
|           zero           |    1b    |                                          固定为0                                          |
|         reserved         |    2b    |                                         固定为11                                          |
|      section_length      |   12b    |                                      后面数据的长度                                       |
|      program_number      |   16b    |                       频道号码,表示当前的PMT关联到的频道,取值0x0001                       |
|         reserved         |    2b    |                                         固定为11                                          |
|      version_number      |    5b    |                        版本号,固定为00000,如果PAT有变化则版本号加1                        |
|  current_next_indicator  |    1b    |                                          固定为1                                          |
|      section_number      |    8b    |                                        固定为0x005                                        |
|   last_section_number    |    8b    |                                        固定为0x00                                         |
|         reserved         |    3b    |                                         固定为111                                         |
|         PCR_PID          |   13b    |                      PCR(节目参考时钟)所在TS分组的PID,指定为视频PID                       |
|         reserved         |    4b    |                                        固定为1111                                         |
|   program_info_length    |   12b    |                             节目描述信息,指定为0x000表示没有                              |
|                          | 开始循环 |                                                                                           |
|       stream_type        |    8b    | 流类型,标志是Video还是Audio还是其他数据,h.264编码对应0x1b,aac编码对应0x0f,mp3编码对应0x03 |
|         reserved         |    3b    |                                         固定为111                                         |
|      elementary_PID      |   13b    |                                  与stream_type对应的PID                                   |
|         reserved         |    4b    |                                        固定为1111                                         |
|      ES_info_length      |   12b    |                               描述信息,指定为0x000表示没有                                |
|                          | 结束循环 |                                                                                           |
|          CRC32           |   32b    |                                   前面数据的CRC32校验码                                   |

#### 3.3.2. PES层

|       名称        | 长度  |                              说明                              |
| :---------------: | :---: | :------------------------------------------------------------: |
|  pes start code   |  3B   |                     开始码,固定为0x000001                      |
|     stream id     |  1B   | 音频取值(0xc0-0xdf),通常为0xc0;视频取值(0xe0-0xef),通常为0xe0  |
| pes packet length |  2B   | 后面pes数据的长度,0表示长度不限制,只有视频数据长度会超过0xffff |
|       flag        |  1B   |       通常取值0x80,表示数据不加密、无优先级、备份的数据        |
|       flag        |  1B   |         取值0x80表示只含有pts,取值0xc0表示含有pts和dts         |
|  pes data length  |  1B   |                    后面数据的长度,取值5或10                    |
|        pts        |  5B   |                            33bit值                             |
|        dts        |  5B   |                            33bit值                             |

- **Packet Elemental Stream**,是在音视频数据上加了时间戳等对数据帧的说明信息。分组的基本码流,将基本码流ES流根据需要分成长度不等的数据包,并加上包头就形成了打包的基本码流PES流。是用来传输ES的一种数据结构。

#### 3.3.3. ES层

- **Elementary Stream**,即音视频数据。不分段的音频、视频或其他信息的连续码流。
      
## [RTSP](./analysis/rtsp)

### 4.1. RTSP简介

- **RTSP(Real Time Streaming Protocol)** 是由Real Network和Netscape共同提出的如何有效地在IP网络上传输流媒体数据的应用层协议。
- RTSP对流媒体提供了诸如暂停、快进等**控制**,而它本身并**不传输数据**,RTSP的作用相当于流媒体服务器的远程控制。服务器端可以自行选择使用**TCP或UDP**来传送串流内容,它的语法和运作跟**HTTP 1.1**类似,但并不特别强调时间同步,所以比较能容忍网络延迟。

### 4.2. RTSP和相关协议

![RTSP和相关协议](https://github.com/gongluck/images/blob/main/RTSP和相关协议.png)
![RTSP工作架构](https://github.com/gongluck/images/blob/main/RTSP工作架构.png)

### 4.3. RTP

- **Real-time Transport Protocol**(实时传输协议)是IETF提出的一个标准,对应的RFC文档为RFC3550。
- RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供端到端的实时传输服务。
- RTP最大的数据包(包含RTP头部)=**MTU-UDP首部–IP报文首部**
- **RTP**报文由两部分组成:**报头和有效载荷**

#### 4.3.1. RTP报头结构

|   名称    | 长度  |                                                                                                    说明                                                                                                    |
| :-------: | :---: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|     V     | 2bit  |                                                                                           RTP协议版本号,当前为2                                                                                            |
|     P     | 1bit  |                                                                 填充标志,P=1则在报文尾部填充一个或多个额外的八位组,但不是有效负荷的一部分                                                                  |
|     X     | 1bit  |                                                                                 扩展标志,X=1则在RTP报头后跟有一个扩展报头                                                                                  |
|    CC     | 4bit  |                                                                                              CSRC标识符的个数                                                                                              |
|     M     | 1bit  |                                                                                      视频:标记一帧结束;音频:标记开始                                                                                       |
|    PT     | 7bit  |                                                                                                有效载荷类型                                                                                                |
|  序列号   |  2B   |                                                         RTP报文序列号,用于乱序重排;序列号的初始值是随机的,同时音频包和视频包的sequence是分别记数的                                                         |
| timestamp |  4B   |                                                                                                   时间戳                                                                                                   |
|   SSRC    |  4B   |                           同步信源标识,指产生媒体流的信源,例如⻨克⻛、摄像机、RTP混合器等。通过SSRC标识,而不依赖于⽹络地址,接收者将根据SSRC标识符来区分不同的信源,进⾏RTP报文的分组                            |
|   CSRC    | 4B*CC | 特约信源标识,指当混合器接收到一个或多个同步信源的RTP报文后,经过混合处理产生一个新的组合RTP报文,并把混合器作为组合RTP报文的SSRC,而将原来所有的SSRC都作为CSRC传送给接收者,使接收者知道组成组合报文的各个SSRC |

- 在静默时,发送方不必发送数据,保持时间戳的增长;在接收端,由于接收到的数据分组的序号没有丢失,就知道没有发生数据丢失,而且只要比较前后分组的时间戳的差异,就可以确定输出的时间间隔。
- 一帧可以由多个NALU组成,在RTP打包的时候如果采用单一包,那么每个NALU就是一个包,每个包里也只有一个NALU。但是因为他们是属于同一帧的,因此时间戳当然相同了。所以,同一时间戳有多个包就说明一帧被分成了多部分进行编码,每部分编码成一个NALU。Marker位为1的那个包里的NALU是该图像的最后一部分。

#### 4.3.2. RTP有效负荷

##### 4.3.2.1. [H264](./analysis/h264)

- **H264 RTP**负载第一个字节的结构和H.264的NALU头结构一致,可以把它认为是RTP H264负载类型字节,完全是多增加的一个字节,不影响后面的NALU结构。

###### 4.3.2.1.1. 单一NAL单元模式

![RTP的H264单一NAL单元模式](https://github.com/gongluck/images/blob/main/RTP的H264单一NAL单元模式.png)

- 对于NALU的长度小于MTU大小的包,一般采用单一NAL单元模式。
- 对于一个原始的H.264 NALU单元常由[Start Code] [NALU Header] [NALU Payload]三部分组成,其中Start Code用于标示这是一个NALU单元的开始,必须是"00 00 00 01"或"00 00 01",NALU头仅一个字节,其后都是NALU单元内容。打包时去除"00 00 01"或"00 00 00 01"的开始码,把其他数据封包的RTP包即可。

###### 4.3.2.1.2. 组合打包模式

![RTP的H264组合打包模式](https://github.com/gongluck/images/blob/main/RTP的H264组合打包模式.png)

- 当NALU的长度特别小时,可以把几个NALU单元封在一个RTP包中。
- 优点:网络传输效率高。
- 缺点:多帧缓存后再发送容易产生延迟。

###### 4.3.2.1.3. 分包模式

![RTP的H264分包模式](https://github.com/gongluck/images/blob/main/RTP的H264分包模式.png)

- 当NALU的长度超过MTU时,就必须对NALU单元进行分片分包,也称为Fragmentation Units (FUs)。本荷载类型允许分片一个NAL单元到几个RTP包中。
- FU-A由1字节的FU indicator,1字节的FU header和分片单元荷载组成。

####### 4.3.2.1.3.1. FU indicator

![RTP的H264分包模式FUindicator](https://github.com/gongluck/images/blob/main/RTP的H264分包模式FUindicator.png)

- FU指示字节的类型域的28、29分别表示FU-A和FU-B。
- NRI域的值必须根据分片NAL单元的NRI域的值设置。
- NRI为帧重要程度:00可以丢;11不能丢。
- F一般设置0。

####### 4.3.2.1.3.2. FU header

![RTP的H264分包模式FUheader](https://github.com/gongluck/images/blob/main/RTP的H264分包模式FUheader.png)

- S:1bit,当设置成1,开始位指示分片NAL单元的开始。当跟随的FU荷载不是分片NAL单元荷载的开始,开始位设为0。
- E:1bit,当设置成1,结束位指示分片NAL单元的结束.即,荷载的最后字节也是分片NAL单元的最后一个字节。当跟随的FU荷载不是分片NAL单元的最后分片,结束位设置为0。
- R:1bit,保留位必须设置为0,接收者必须忽略该位。
- Type:5bits,NAL单元荷载类型定义。

##### 4.3.2.2. [AAC](./analysis/h264)

![RTP的AAC包结构](https://github.com/gongluck/images/blob/main/RTP的AAC包结构.png)

###### 4.3.2.2.1. AU Header Section

![RTP的AAC包AUHeaderSection](https://github.com/gongluck/images/blob/main/RTP的AAC包AUHeaderSection.png)

- AU-headers-length:占2个字节,单位为bits,表示所有AU-header + padding bits占用的位数。
- 每个AU-header对应一个AU data。

####### 4.3.2.2.1.1. AU-headers-length

- 占2个字节,单位为bits,表示所有AU-header + padding bits占用的位数。
- 一个AU-header长度是两个字节(16bit),因为可以有多个au-header,所以AU-headers-length的值是16的倍数,一般音频都是单个音频数据流的发送,所以AU-headers-length的值是16。
- 因为单位是bit,除以8就是auHeader的字节长度;又因为单个auheader字节长度是2字节,所以再除以2就是auheader的个数。

####### 4.3.2.2.1.2. AU-header

![RTP的AAC包AUHeader](https://github.com/gongluck/images/blob/main/RTP的AAC包AUHeader.png)

|      名称      |          长度          |              说明              |
| :------------: | :--------------------: | :----------------------------: |
|    AU-size     |    由sizeLength决定    |  表示本段音频数据占用的字节数  |
|    AU-Index    |   由indexLength决定    |    表示本段的序号,通常0开始    |
| AU-Index-delta | 由indexDeltaLength决定 | 表示本段序号与上一段序号的差值 |

其它的值都是可选的,如果sdp中没有出现相关的参数(或者为0),则表示它们不出现。

### 4.4. RTCP

- 实时传输控制协议RTCP(Real-time Transport Control Protocol),向会话中的所有成员周期性地发送控制包来实现的,应用程序通过接收这些控制数据包,从中获取会话参与者的相关资料,以及网络状况、分组丢失概率等反馈信息,从而能够对服务质量进行控制或者对网络状况进行诊断。
- RTP为Internet上端到端的实时传输提供时间信息和流同步,但并不保证服务质量,服务质量由**RTCP**来提供。

## WebSocket

- WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议；

- WebSocket 使得客户端和服务器之间的数据交换变得更加简单,允许服务端主动向客户端推送数据。在 WebSocket API 中,浏览器和服务器只需要完成一次握手,两者之间就直接可以创建持久性的连接,并进行双向数据传输；

    ![Ajax和WebSocket](./images/Ajax和WebSocket.png)

- 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求,连接建立以后,客户端和服务器端就可以通过TCP 连接直接交换数据；

- 当你获取 Web Socket 连接后,你可以通过 send() 方法来向服务器发送数据,并通过onmessage 事件来接收服务器返回的数据；

- 为了建立一个 WebSocket 连接,客户端浏览器首先要向服务器发起一个 HTTP 请求,这个请求和通常的 HTTP 请求不同,包含了一些附加头信息,其中附加头信息"Upgrade: WebSocket"表明这是一个申请协议升级的 HTTP 请求,服务器端解析这些附加的头信息然后产生应答信息返回给客户端,客户端和服务器端的 WebSocket 连接就建立起来了,双方就可以通过这个连接通道自由的传递信息,并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接；

- 服务器端使用websocket需要安装nodejs-­websocket

    ```shell
    cd 工程目录
    sudo npm init
    #创建package.json文件
    sudo npm install nodejs-websocket
    ```

## ```WebRTC```

### ```WebRTC```框架

  ![WebRTC架构](./images/WebRTC/WebRTC架构.png)

### ```WebRTC```连接过程

  ![WebRTC连接过程](./images/WebRTC/WebRTC连接过程.png)

### ```ICE Candidate```

  <details>
  <summary>ICE Candidate</summary>

  ```json
  {
    "candidate": "candidate:foundation icegroupid type priority ip port typ host generation x ufrag xxxx network-cost 999",
    "sdpMid": "0",
    "sdpMLineIndex": 0
  }
  {
    "candidate": "candidate:545662605 1 udp 2113937151 a8e7c788-6636-4392-b5af-08253ad10ee5.local 51579 typ host generation 0 ufrag 0XDd network-cost 999",
    "sdpMid": "0",
    "sdpMLineIndex": 0
  }
  ```
  </details>

  - ```candidate```:```ICE```候选
  - ```foundation```:用于标志和区分来自同一个```stun```的不同的候选者,```ID```标识
  - ```icegroupid```:```ICE```的组```ID```
  - ```type```:协议类型
  - ```priority```:优先级
  - ```ip```:```ip```地址
  - ```port```:端口
  - ```typ```:标识后面字段的属性类型是候选类型
    - ```host```:本地接口获取到的```candidate```
    - ```srflx```:```NAT```网关在公网侧的```IP```地址，通过```STUN```或者```TURN```收集(```server reflexive candidate```)
    - ```prflx```:可以在```ICE```的后续阶段中获取到(```peer reflexive candidate```)
    - ```relay```:```TURN```服务器的公网转发地址，通过```TURN```收集
  - ```generation x```:表明当前是第几代的候选 
  - ```ufrag xxxx```:分配的用户名标识
  - ```network-cost xxx```:网卡标识

### ```SDP```

  <details>
  <summary>SDP</summary>

  ```text
  v=0
  o=- 6430937235515578749 2 IN IP4 127.0.0.1
  s=-
  t=0 0
  a=group:BUNDLE 0 1
  a=extmap-allow-mixed
  a=msid-semantic: WMS dGBa2UextnqOyqBq7ReErAi6YWmljy3LhuAA
  m=audio 9 UDP/TLS/RTP/SAVPF 111 63 103 104 9 0 8 106 105 13 110 112 113 126
  c=IN IP4 0.0.0.0
  a=rtcp:9 IN IP4 0.0.0.0
  a=ice-ufrag:Acgf
  a=ice-pwd:7zfBgyFzPfptbrklnxbgjOkF
  a=ice-options:trickle
  a=fingerprint:sha-256 4A:43:A2:A8:3A:50:84:EF:C2:E7:8A:20:1A:35:07:7E:BE:03:24:E3:CD:7C:1E:4F:98:A8:00:44:5A:96:29:5C
  a=setup:active
  a=mid:0
  a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
  a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
  a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
  a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid
  a=sendrecv
  a=msid:dGBa2UextnqOyqBq7ReErAi6YWmljy3LhuAA 5c7496b6-2cd9-4bb8-a521-e881d5d0a241
  a=rtcp-mux
  a=rtpmap:111 opus/48000/2
  a=rtcp-fb:111 transport-cc
  a=fmtp:111 minptime=10;useinbandfec=1
  a=rtpmap:63 red/48000/2
  a=fmtp:63 111/111
  a=rtpmap:103 ISAC/16000
  a=rtpmap:104 ISAC/32000
  a=rtpmap:9 G722/8000
  a=rtpmap:0 PCMU/8000
  a=rtpmap:8 PCMA/8000
  a=rtpmap:106 CN/32000
  a=rtpmap:105 CN/16000
  a=rtpmap:13 CN/8000
  a=rtpmap:110 telephone-event/48000
  a=rtpmap:112 telephone-event/32000
  a=rtpmap:113 telephone-event/16000
  a=rtpmap:126 telephone-event/8000
  a=ssrc:1871063466 cname:csbDbPUNcSfBoceC
  m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 124 119 123 117 35 36 114 115 116 62 118
  c=IN IP4 0.0.0.0
  a=rtcp:9 IN IP4 0.0.0.0
  a=ice-ufrag:Acgf
  a=ice-pwd:7zfBgyFzPfptbrklnxbgjOkF
  a=ice-options:trickle
  a=fingerprint:sha-256 4A:43:A2:A8:3A:50:84:EF:C2:E7:8A:20:1A:35:07:7E:BE:03:24:E3:CD:7C:1E:4F:98:A8:00:44:5A:96:29:5C
  a=setup:active
  a=mid:1
  a=extmap:14 urn:ietf:params:rtp-hdrext:toffset
  a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
  a=extmap:13 urn:3gpp:video-orientation
  a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
  a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay
  a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type
  a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing
  a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space
  a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid
  a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
  a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id
  a=sendrecv
  a=msid:dGBa2UextnqOyqBq7ReErAi6YWmljy3LhuAA 20da8f42-dfb8-44fa-9c51-8e3832ed4a05
  a=rtcp-mux
  a=rtcp-rsize
  a=rtpmap:96 VP8/90000
  a=rtcp-fb:96 goog-remb
  a=rtcp-fb:96 transport-cc
  a=rtcp-fb:96 ccm fir
  a=rtcp-fb:96 nack
  a=rtcp-fb:96 nack pli
  a=rtpmap:97 rtx/90000
  a=fmtp:97 apt=96
  a=rtpmap:98 VP9/90000
  a=rtcp-fb:98 goog-remb
  a=rtcp-fb:98 transport-cc
  a=rtcp-fb:98 ccm fir
  a=rtcp-fb:98 nack
  a=rtcp-fb:98 nack pli
  a=fmtp:98 profile-id=0
  a=rtpmap:99 rtx/90000
  a=fmtp:99 apt=98
  a=rtpmap:100 VP9/90000
  a=rtcp-fb:100 goog-remb
  a=rtcp-fb:100 transport-cc
  a=rtcp-fb:100 ccm fir
  a=rtcp-fb:100 nack
  a=rtcp-fb:100 nack pli
  a=fmtp:100 profile-id=2
  a=rtpmap:101 rtx/90000
  a=fmtp:101 apt=100
  a=rtpmap:102 H264/90000
  a=rtcp-fb:102 goog-remb
  a=rtcp-fb:102 transport-cc
  a=rtcp-fb:102 ccm fir
  a=rtcp-fb:102 nack
  a=rtcp-fb:102 nack pli
  a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f
  a=rtpmap:121 rtx/90000
  a=fmtp:121 apt=102
  a=rtpmap:127 H264/90000
  a=rtcp-fb:127 goog-remb
  a=rtcp-fb:127 transport-cc
  a=rtcp-fb:127 ccm fir
  a=rtcp-fb:127 nack
  a=rtcp-fb:127 nack pli
  a=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f
  a=rtpmap:120 rtx/90000
  a=fmtp:120 apt=127
  a=rtpmap:125 H264/90000
  a=rtcp-fb:125 goog-remb
  a=rtcp-fb:125 transport-cc
  a=rtcp-fb:125 ccm fir
  a=rtcp-fb:125 nack
  a=rtcp-fb:125 nack pli
  a=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f
  a=rtpmap:107 rtx/90000
  a=fmtp:107 apt=125
  a=rtpmap:108 H264/90000
  a=rtcp-fb:108 goog-remb
  a=rtcp-fb:108 transport-cc
  a=rtcp-fb:108 ccm fir
  a=rtcp-fb:108 nack
  a=rtcp-fb:108 nack pli
  a=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f
  a=rtpmap:109 rtx/90000
  a=fmtp:109 apt=108
  a=rtpmap:124 H264/90000
  a=rtcp-fb:124 goog-remb
  a=rtcp-fb:124 transport-cc
  a=rtcp-fb:124 ccm fir
  a=rtcp-fb:124 nack
  a=rtcp-fb:124 nack pli
  a=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d001f
  a=rtpmap:119 rtx/90000
  a=fmtp:119 apt=124
  a=rtpmap:123 H264/90000
  a=rtcp-fb:123 goog-remb
  a=rtcp-fb:123 transport-cc
  a=rtcp-fb:123 ccm fir
  a=rtcp-fb:123 nack
  a=rtcp-fb:123 nack pli
  a=fmtp:123 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=4d001f
  a=rtpmap:117 rtx/90000
  a=fmtp:117 apt=123
  a=rtpmap:35 AV1/90000
  a=rtcp-fb:35 goog-remb
  a=rtcp-fb:35 transport-cc
  a=rtcp-fb:35 ccm fir
  a=rtcp-fb:35 nack
  a=rtcp-fb:35 nack pli
  a=rtpmap:36 rtx/90000
  a=fmtp:36 apt=35
  a=rtpmap:114 H264/90000
  a=rtcp-fb:114 goog-remb
  a=rtcp-fb:114 transport-cc
  a=rtcp-fb:114 ccm fir
  a=rtcp-fb:114 nack
  a=rtcp-fb:114 nack pli
  a=fmtp:114 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f
  a=rtpmap:115 rtx/90000
  a=fmtp:115 apt=114
  a=rtpmap:116 red/90000
  a=rtpmap:62 rtx/90000
  a=fmtp:62 apt=116
  a=rtpmap:118 ulpfec/90000
  a=ssrc-group:FID 84266309 3067595669
  a=ssrc:84266309 cname:csbDbPUNcSfBoceC
  a=ssrc:3067595669 cname:csbDbPUNcSfBoceC
  ```
  </details>

#### ```session metadata```

  <details>
  <summary>session metadata</summary>

  ```text
  v=0
  o=- 6430937235515578749 2 IN IP4 127.0.0.1
  s=-
  t=0 0
  a=group:BUNDLE 0 1
  a=extmap-allow-mixed
  a=msid-semantic: WMS dGBa2UextnqOyqBq7ReErAi6YWmljy3LhuAA
  ```
  </details>

  - ```v=```版本号
  - ```o=```会话发起者信息
  - ```s=```会话名称
  - ```t=```会话起止时间
  - ```a=group:BUNDLE mid0 mid1 ...```复用传输层(五元组)的```mid```
  - ```a=msid-semantic: WMS``` ```(WebRTC Media Stream(WMS))```的```id```
  
#### ```media section```

  <details>
  <summary>media section</summary>

  ```text
  m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 124 119 123 117 35 36 114 115 116 62 118
  c=IN IP4 0.0.0.0
  a=rtcp:9 IN IP4 0.0.0.0
  a=ice-ufrag:Acgf
  a=ice-pwd:7zfBgyFzPfptbrklnxbgjOkF
  a=ice-options:trickle
  a=fingerprint:sha-256 4A:43:A2:A8:3A:50:84:EF:C2:E7:8A:20:1A:35:07:7E:BE:03:24:E3:CD:7C:1E:4F:98:A8:00:44:5A:96:29:5C
  a=setup:active
  a=mid:1
  a=extmap:14 urn:ietf:params:rtp-hdrext:toffset
  a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
  a=extmap:13 urn:3gpp:video-orientation
  a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
  a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay
  a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type
  a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing
  a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space
  a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid
  a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
  a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id
  a=sendrecv
  a=msid:dGBa2UextnqOyqBq7ReErAi6YWmljy3LhuAA 20da8f42-dfb8-44fa-9c51-8e3832ed4a05
  a=rtcp-mux
  a=rtcp-rsize
  a=rtpmap:96 VP8/90000
  a=rtcp-fb:96 goog-remb
  a=rtcp-fb:96 transport-cc
  a=rtcp-fb:96 ccm fir
  a=rtcp-fb:96 nack
  a=rtcp-fb:96 nack pli
  a=rtpmap:97 rtx/90000
  a=fmtp:97 apt=96
  a=rtpmap:98 VP9/90000
  a=rtcp-fb:98 goog-remb
  a=rtcp-fb:98 transport-cc
  a=rtcp-fb:98 ccm fir
  a=rtcp-fb:98 nack
  a=rtcp-fb:98 nack pli
  a=fmtp:98 profile-id=0
  a=rtpmap:99 rtx/90000
  a=fmtp:99 apt=98
  a=rtpmap:100 VP9/90000
  a=rtcp-fb:100 goog-remb
  a=rtcp-fb:100 transport-cc
  a=rtcp-fb:100 ccm fir
  a=rtcp-fb:100 nack
  a=rtcp-fb:100 nack pli
  a=fmtp:100 profile-id=2
  a=rtpmap:101 rtx/90000
  a=fmtp:101 apt=100
  a=rtpmap:102 H264/90000
  a=rtcp-fb:102 goog-remb
  a=rtcp-fb:102 transport-cc
  a=rtcp-fb:102 ccm fir
  a=rtcp-fb:102 nack
  a=rtcp-fb:102 nack pli
  a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f
  a=rtpmap:121 rtx/90000
  a=fmtp:121 apt=102
  a=rtpmap:127 H264/90000
  a=rtcp-fb:127 goog-remb
  a=rtcp-fb:127 transport-cc
  a=rtcp-fb:127 ccm fir
  a=rtcp-fb:127 nack
  a=rtcp-fb:127 nack pli
  a=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f
  a=rtpmap:120 rtx/90000
  a=fmtp:120 apt=127
  a=rtpmap:125 H264/90000
  a=rtcp-fb:125 goog-remb
  a=rtcp-fb:125 transport-cc
  a=rtcp-fb:125 ccm fir
  a=rtcp-fb:125 nack
  a=rtcp-fb:125 nack pli
  a=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f
  a=rtpmap:107 rtx/90000
  a=fmtp:107 apt=125
  a=rtpmap:108 H264/90000
  a=rtcp-fb:108 goog-remb
  a=rtcp-fb:108 transport-cc
  a=rtcp-fb:108 ccm fir
  a=rtcp-fb:108 nack
  a=rtcp-fb:108 nack pli
  a=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f
  a=rtpmap:109 rtx/90000
  a=fmtp:109 apt=108
  a=rtpmap:124 H264/90000
  a=rtcp-fb:124 goog-remb
  a=rtcp-fb:124 transport-cc
  a=rtcp-fb:124 ccm fir
  a=rtcp-fb:124 nack
  a=rtcp-fb:124 nack pli
  a=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d001f
  a=rtpmap:119 rtx/90000
  a=fmtp:119 apt=124
  a=rtpmap:123 H264/90000
  a=rtcp-fb:123 goog-remb
  a=rtcp-fb:123 transport-cc
  a=rtcp-fb:123 ccm fir
  a=rtcp-fb:123 nack
  a=rtcp-fb:123 nack pli
  a=fmtp:123 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=4d001f
  a=rtpmap:117 rtx/90000
  a=fmtp:117 apt=123
  a=rtpmap:35 AV1/90000
  a=rtcp-fb:35 goog-remb
  a=rtcp-fb:35 transport-cc
  a=rtcp-fb:35 ccm fir
  a=rtcp-fb:35 nack
  a=rtcp-fb:35 nack pli
  a=rtpmap:36 rtx/90000
  a=fmtp:36 apt=35
  a=rtpmap:114 H264/90000
  a=rtcp-fb:114 goog-remb
  a=rtcp-fb:114 transport-cc
  a=rtcp-fb:114 ccm fir
  a=rtcp-fb:114 nack
  a=rtcp-fb:114 nack pli
  a=fmtp:114 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f
  a=rtpmap:115 rtx/90000
  a=fmtp:115 apt=114
  a=rtpmap:116 red/90000
  a=rtpmap:62 rtx/90000
  a=fmtp:62 apt=116
  a=rtpmap:118 ulpfec/90000
  a=ssrc-group:FID 84266309 3067595669
  a=ssrc:84266309 cname:csbDbPUNcSfBoceC
  a=ssrc:3067595669 cname:csbDbPUNcSfBoceC
  ```
  </details>

  - ```m=video/audio/application``` 可忽略端口 传输协议 数据格式列表
  - ```c=```网络信息(```WebRTC```使用```ICE```协议，所以这个信息无效)
  - ```a=rtcp:```描述```RTCP```的网络信息，但是通常不是实际使用的```IP```和端口
  - ```a=ice-ufrag:``` ```ICE```连接用户名
  - ```a=ice-pwd:``` ```ICE```连接密码
  - ```a=ice-options:```本端支持的```ICE```选项
  - ```a=fingerprint:``` ```DTLS```协商证书
  - ```a=setup:``` ```DTLS```协商时本端角色
    - ```active```发起端(```client```)
    - ```passive```接收端(```server```)
    - ```actpass```既可以是发起端也可以是接收端
  - ```a=mid:```这个```media section```的```id```，对应```BUNDLE```里面的标识
  - ```a=extmap:```描述本端支持的```RTP extension header```的```id```和地址
  - ```a=```媒体方向
    - ```sendrecv```同时收发
    - ```recvonly```只接收
    - ```sendonly```只发送
  - ```a=msid:```媒体流```id``` 媒体轨```id```
  - ```a=rtcp-mux```本端支持```RTP```和```RTCP```连接复用
  - ```a=rtcp-rsize```本端希望缩减```RTCP```协议所使用的流量
  - ```a=rtpmap:``` ```RTP```协议的```payload type``` 编码格式名称```/```音频采样率或视频时钟频率
  - ```a=fmtp:``` ```RTP```协议的```payload type``` 补充描述编码格式的参数
    - ```max-fr=```最大帧率
    - ```profile-level-id=``` ```H264```的```profile level id```
    - ```apt=```关联的```payload type```
  - ```a=rtpmap:``` ```RTP```协议的```payload type``` ```RTCP```反馈机制
    - ```goog-remb```  ```Receiver Estimated Maximum Bitrate```接收端最大接收码率估测，使用```RTCP```反馈接收端的带宽估计信息
    - ```transport-cc```使用发送端拥塞控制机制
    - ```ccm fir```使用请求关键帧机制
    - ```nack```使用丢包通知机制
    - ```nack pli```使用图像丢失通知机制
  - ```a=ssrc-group:FID``` 数据源 重传流
  - ```a=ssrc:``` ```RTP```媒体流的一个数据源 数据源的属性
    - ```msid:```、```mslabel:```、```label:```数据源关联的流```id```和轨```id```

#### [修改```SDP```的例子](https://github.com/gongluck/sourcecode/blob/main/webrtc/examples/androidapp/src/org/appspot/apprtc/PeerConnectionClient.java)

  <details>
  <summary>设置优先编码器</summary>

  ```java
  //拼接字符串
  private static String joinString(
    Iterable<? extends CharSequence> s,
    String delimiter,
    boolean delimiterAtEnd
  ) {
    Iterator<? extends CharSequence> iter = s.iterator();
    if (!iter.hasNext()) {
      return "";
    }
    StringBuilder buffer = new StringBuilder(iter.next());
    while (iter.hasNext()) {
      buffer.append(delimiter).append(iter.next());
    }
    if (delimiterAtEnd) {
      buffer.append(delimiter);
    }
    return buffer.toString();
  }

  //移动优先集到头部
  private static @Nullable String movePayloadTypesToFront(
    List<String> preferredPayloadTypes,
    String mLine
  ) {
    // The format of the media description line should be: m=<media> <port> <proto> <fmt> ...
    final List<String> origLineParts = Arrays.asList(mLine.split(" "));
    if (origLineParts.size() <= 3) { //简单校验
      Log.e(TAG, "Wrong SDP media description format: " + mLine);
      return null;
    }
    final List<String> header = origLineParts.subList(0, 3);
    //非优先集
    final List<String> unpreferredPayloadTypes = new ArrayList<>(
      origLineParts.subList(3, origLineParts.size())
    );
    //在非优先集中去除优先集
    unpreferredPayloadTypes.removeAll(preferredPayloadTypes);
    // Reconstruct the line with `preferredPayloadTypes` moved to the beginning of the payload
    // types.
    //重新构造字符串 header + 优先集 + 非优先集
    final List<String> newLineParts = new ArrayList<>();
    newLineParts.addAll(header);
    newLineParts.addAll(preferredPayloadTypes);
    newLineParts.addAll(unpreferredPayloadTypes);
    return joinString(newLineParts, " ", false/* delimiterAtEnd */);
  }

  //设置优先编码器
  private static String preferCodec(String sdp, String codec, boolean isAudio) {
    //分割每一行
    final String[] lines = sdp.split("\r\n");
    //查找对应媒体的开始行
    final int mLineIndex = findMediaDescriptionLine(isAudio, lines);
    if (mLineIndex == -1) {
      Log.w(TAG, "No mediaDescription line, so can't prefer " + codec);
      return sdp;
    }
    // A list with all the payload types with name `codec`. The payload types are integers in the
    // range 96-127, but they are stored as strings here.
    final List<String> codecPayloadTypes = new ArrayList<>();
    // a=rtpmap:<payload type> <encoding name>/<clock rate> [/<encoding parameters>]
    final Pattern codecPattern = Pattern.compile(
      "^a=rtpmap:(\\d+) " + codec + "(/\\d+)+[\r]?$" //匹配编码格式名称codec
    );
    for (String line : lines) {
      Matcher codecMatcher = codecPattern.matcher(line);
      if (codecMatcher.matches()) {
        codecPayloadTypes.add(codecMatcher.group(1));
      }
    }
    if (codecPayloadTypes.isEmpty()) {
      Log.w(TAG, "No payload types with name " + codec);
      return sdp;
    }

    final String newMLine = movePayloadTypesToFront(
      codecPayloadTypes,
      lines[mLineIndex]
    );
    if (newMLine == null) {
      return sdp;
    }
    Log.d(
      TAG,
      "Change media description from: " + lines[mLineIndex] + " to " + newMLine
    );
    lines[mLineIndex] = newMLine;
    return joinString(Arrays.asList(lines), "\r\n", true/* delimiterAtEnd */);
  }
  ```
  </details>